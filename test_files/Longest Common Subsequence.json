[
  {
    "slide number": 1,
    "original text": "Longest Common Subsequence ",
    "explanation": "The Longest Common Subsequence (LCS) is a well-known algorithm used to compare two different strings. The algorithm looks for the longest common subsequence in both strings. A subsequence is defined as a sequence of characters that appear in the same order in the longer string, but not necessarily contiguous. The length of the LCS is measured by the number of characters appearing in both strings. \n\nThe algorithm works by comparing the two strings and finding the longest common subsequence between them. To do this, it looks for the characters in both strings that have the same values and that appear in the same order. This is done by scanning the two strings from left to right and then taking the longest common subsequence it can find. Once it finds the common subsequence, it then looks for the longest subsequence that appears in both strings and adds it to the LCS. The algorithm continues scanning both strings until it finds the longest common subsequence. \n\nThe LCS algorithm is useful in many applications, such as finding the similarity between two documents, providing an overview of the relationship between two texts, and finding the most similar points between two sequences. The algorithm can also be used in sequence alignment and in-text mining."
  },
  {
    "slide number": 2,
    "original text": "Longest Common Subsequence Consider a string of characters: X = ABCBDAB. A subsequence is obtained by deleting some (any) characters of X.  E.g. ABBB is a subsequence of X, as is ABD.  But AABB is not a subsequence. Let X = (x1, x2, . . . ,  xm ) be a sequence. Z = (z1, z2, . . . ,  zk ) is  subseq . of X if there is an index sequence (i1, . . . ,  ik )  s.t .  zj  =  xij , for j = 1, . . . , k. Index sequence for ABBB is (1, 2, 4, 7). ",
    "explanation": "The Longest Common Subsequence is the longest sequence of characters that are common to both strings. A common subsequence of two strings is a subsequence that is present in both strings. For example, given two strings X and Y, let X = ABCBDAB and Y = BDCABA, the Longest Common Subsequence is BDAB. This is because BDAB appears in both strings and is the longest sequence of characters where the order of the characters is preserved. To find the Longest Common Subsequence, we can use dynamic programming. We start by defining a matrix L[m+1][n+1], where m and n are the lengths of the two strings being compared. The cell L[i][j] will contain the length of the Longest Common Subsequence for the string X[0...i] and Y[0...j]. As we fill out the matrix, the last cell of the matrix will hold the length of the Longest Common Subsequence."
  },
  {
    "slide number": 3,
    "original text": "Longest Common Subsequence Given two sequences X and Y ,  \ufb01nd  their longest common subsequence. If X = (A,B,C,B,D,A,B) and Y = (B,D,C,A,B,A), then (B,C,A) is a common sequence, but not LCS.  (B,D,A,B) is a LCS. How do we  \ufb01nd  an LCS? Can some form of Greedy work? Suggestions? ",
    "explanation": "A longest common subsequence (LCS) is a sequence of characters from two strings X and Y which are both present in X and Y, but not necessarily in consecutive order. For example, if X = (A,B,C,B,D,A,B) and Y = (B,D,C,A,B,A), then (B,C,A) is a common sequence, but not LCS since it is not the longest common sequence in the two strings. The longest common subsequence is (B,D,A,B). \n\nThere are two ways to find an LCS: an na\u00efve approach and a more efficient approach. Na\u00efve approach involves generating all possible combinations of the characters in the two strings and checking to see if they are a common subsequence. This approach works but is too slow for longer strings. \n\nA more efficient approach is to use dynamic programming. This approach involves solving sub-problems and storing the results in a table. As the size of the strings increase, more sub-problems have to be solved. At the end, the strings X and Y can be compared and the LCS can be determined. \n\nUnfortunately, a greedy approach cannot be used to solve the LCS problem because a greedy algorithm only makes a decision at every step that seems best at that moment, without regard to the effect it will have on future solutions. This approach would not be able to distinguish if a particular subsequence is the longest one."
  },
  {
    "slide number": 4,
    "original text": "Trial Ideas Greedy-1:  Scan X. Find the  \ufb01rst  letter matching y1; take it and continue. Problem: only matches  pre\ufb01x  substrings of Y . Greedy-2:  Find the most frequent letters of X; or sort the letters by their frequency. Try to match in frequency order. Problem: Frequency can be irrelevant. E.g. suppose all letters of X are distinct. ",
    "explanation": "The text is explaining two different greedy trial ideas for a problem to find a string X that matches a substring of a larger string Y. Greedy-1 involves scanning string X and taking the first letter that matches y1. The problem with this approach is that it only matches the prefix substring of Y. \n\nGreedy-2 involves finding the most frequent letters of X or sorting the letters by their frequency, and then trying to match these letters in frequency order. The problem with this approach is that the frequency of letters can be irrelevant, as an example could be that all letters in X are distinct."
  },
  {
    "slide number": 5,
    "original text": "Properties ",
    "explanation": "Properties are like attributes that can be associated with a particular object. They provide the ability to store and retrieve data. Properties allow for a flexible and efficient way of dealing with data and objects, and can be used to customize the behavior of an object. A property is usually defined as a pair of methods, one for setting and one for getting the value of the property. For example, if an object had a property called 'size', then the getter and setter methods for that property might look like this:\n\n// Getter\npublic int getSize() {\n    return this.size;\n}\n\n// Setter\npublic void setSize(int size) {\n    this.size = size;\n}\n\nProperties are useful for allowing customization of the behavior and data of an object. The get and set methods for the properties are typically implemented using access modifiers such as \"private\" or \"protected\" to maintain the integrity of the data contained in the object. In addition, properties can be used to provide initialization and validation of data inside an object."
  }
]